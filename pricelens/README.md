# Pricelens: Техническая документация

> **Версия:** 0.1 (Прототип фронтенда и базовая модель данных)
> **Последнее обновление:** 1 августа 2025 г.

Этот документ описывает техническую реализацию и архитектуру модуля `pricelens`.

## 1. Назначение модуля

`Pricelens` — это система мониторинга контура загрузки прайс-листов. Ее задача — отслеживать, агрегировать и предоставлять интерфейс для расследования ошибок, возникающих на различных этапах пайплайна (получение почты, загрузка с FTP, консолидация данных).

## 2. Архитектура и поток данных

На данном этапе реализован фронтенд-прототип и модели данных. Бэкенд-логика для обработки данных пока не реализована и симулируется в представлениях (`views.py`).

```mermaid
flowchart TD
    subgraph Внешние сервисы
        direction LR
        S1["load_mail"] --> |HTTP POST| API
        S2["load_ftp"] --> |HTTP POST| API
        S3["consolidate"] --> |HTTP POST| API
    end

    subgraph admin2 (Django)
        API["/api/v1/pricelens/log_event/"] -->|вызов| Utils["utils.log_investigation_event()"]
        Utils -->|запись| DB[(Postgres: pricelens_investigation)]
        
        subgraph "Pricelens UI"
            direction TB
            Views["Django Views (pricelens.views)"]
            Templates["Шаблоны (DaisyUI)"]
        end

        DB -->|чтение| Views
        Views --> Templates
    end

    subgraph Пользователь
        U["Инженер/Оператор"]
    end

    U -->|просмотр| Templates
```

## 3. Модели данных

Основа системы — несколько моделей Django, которые хранят информацию о событиях и состоянии поставщиков. Модели разделены между приложениями `common` и `pricelens` для лучшей организации.

### 3.1 `common.models.Supplier`

Центральная модель, представляющая собой поставщика. Является единым источником правды для всех данных, связанных с поставщиками.

- **Назначение:** Определяет уникального поставщика в системе.
- **Ключевые поля:**
    - `supid` (`PositiveIntegerField`, `primary_key`): Уникальный ID поставщика, соответствующий `dif_id` из ClickHouse.
    - `name` (`CharField`): Имя поставщика.

### 3.2 `pricelens.models.Investigation`

Основная модель, представляющая собой единичное событие ошибки, требующее расследования.

- **Назначение:** Хранит все данные о конкретной ошибке: когда произошла, у какого поставщика, на каком этапе и с каким текстом ошибки.
- **Ключевые поля:**
    - `id` (`UUIDField`): Уникальный, непредсказуемый идентификатор.
    - `supplier` (`ForeignKey` к `common.Supplier`): Четкая связь с поставщиком, у которого произошла ошибка.
    - `status` (`IntegerChoices`): Статус расследования (`Открыто`, `Решено`, `Не решено`).
    - `investigator` (`ForeignKey` к `User`): Ссылка на пользователя, который проводит расследование.

### 3.3 `pricelens.models.CadenceProfile`

Агрегированная информация о "здоровье" и ритмичности каждого поставщика.

- **Назначение:** Хранит аналитические метрики, рассчитанные на основе данных из ClickHouse, для классификации поставщиков и выявления аномалий в их ритме поставок.
- **Ключевые поля:**
    - `supplier` (`OneToOneField` к `common.Supplier`): Связь с основной моделью поставщика.
    - `bucket` (`TextChoices`): Категория поставщика, рассчитанная по гибридной логике:
        - **`dead`**: Поставок не было 28 или более дней.
        - **`consistent` (Стабильные)**: Поставщик считается стабильным, если выполняется **хотя бы одно** из условий:
            1.  Общая нестабильность (стандартное отклонение `sd_gap`) не превышает типичный интервал (`med_gap`).
            2.  Процент "плохих" промежутков (выбросов, которые более чем вдвое превышают `med_gap`) составляет **менее 20%** от общего числа поставок.
        - **`inconsistent` (Нестабильные)**: Все остальные поставщики, которые не являются "мертвыми", но провалили обе проверки на стабильность.
- **Обоснование логики:** Гибридный подход был выбран, чтобы система была устойчива к единичным, большим сбоям в поставках (которые могли произойти по нашей вине), но при этом оставалась чувствительной к поставщикам с действительно частыми и непредсказуемыми сбоями.

### 3.4 `pricelens.models.CadenceDaily`

Ежедневная сводка по каждому поставщику.

- **Назначение:** Детализированная статистика за каждый день: были ли файлы, сколько было попыток загрузки, сколько ошибок.
- **Ключевые поля:**
    - `date` (`DateField`)
    - `supplier` (`ForeignKey` к `common.Supplier`)
    - `unique_together`: (`date`, `supplier`)

## 4. Пользовательский интерфейс

На данный момент реализован полнофункциональный UI-прототип с использованием Django Templates и **DaisyUI**. Вся информация в представлениях является статичной (dummy data) и не отражает реальных данных из БД.

- **Dashboard (`/pricelens/`):** Главная панель с ключевыми метриками.
- **Queue (`/pricelens/queue/`):** Таблица со списком всех открытых расследований с пагинацией.
- **Investigate (`/pricelens/investigate/<id>/`):** Детальная страница для одного расследования с формой для добавления заметок и смены статуса.

## 5. API (`pricelens/api.py`)

Для приема событий из внешних сервисов реализован REST API endpoint.

### 5.1 `POST /api/v1/pricelens/log_event/`

- **Назначение:** Основная точка входа для регистрации событий ошибок из `load_mail`, `load_ftp` и `consolidate`.
- **Аутентификация:** `TokenAuthentication`. Запросы должны содержать заголовок `Authorization: Token <your_token>`.
- **Тело запроса (JSON):

```json
{
    "event_dt": "2025-08-01T12:30:00Z",
    "supid": 1234,
    "reason": 101,
    "stage": "load_mail",
    "file_path": "/path/to/failed/file.xlsx"
}
```

- **Ответы:**
    - `201 Created`: Событие успешно зарегистрировано.
    - `400 Bad Request`: Ошибка валидации данных (неверный формат, отсутствуют обязательные поля).
    - `401 Unauthorized`: Неверный или отсутствующий токен аутентификации.

## 6. Сериализаторы (`pricelens/serializers.py`)

Для валидации входящих данных API используется `LogEventSerializer`.

- **Класс:** `serializers.Serializer` (не `ModelSerializer`).
- **Обоснование выбора:**
    1.  **Разделение контрактов:** API принимает данные в одном формате (DTO - Data Transfer Object), а модель `Investigation` хранит их в другом. Сериализатор выступает в роли четкого контракта для API, не привязанного к структуре БД.
    2.  **Трансформация данных:** Входящее поле `reason` (числовой код ошибки) используется для заполнения двух полей в модели: `error_id` и `error_text`. `Serializer` позволяет гибко управлять этой логикой в представлении (`view`).
    3.  **Поля, генерируемые сервером:** Такие поля, как `status`, `created_at` и `id`, устанавливаются сервером и не должны приниматься от клиента. `Serializer` упрощает эту логику по сравнению с `ModelSerializer`, где эти поля пришлось бы явно помечать как `read_only`.
