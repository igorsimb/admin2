# 3. simplify (tech plan)





# Technical Plan for Cross-Dock Functionality Simplification

Let's create a detailed technical plan for implementing the cross-dock functionality in Django. I'll break this down into specific components with code examples that can be easily adapted when you're ready to implement.

## 1. Django Models

First, let's define the models we'll need in the`cross_dock`app:

```python
# cross_dock/models.py
from django.db import models
import uuid

class CrossDockTask(models.Model):
    """Model for tracking cross-dock tasks."""
    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('RUNNING', 'Running'),
        ('SUCCESS', 'Success'),
        ('FAILURE', 'Failure'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='PENDING')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    result_url = models.URLField(null=True, blank=True)
    error_message = models.TextField(null=True, blank=True)
    
    # Store the original request parameters
    input_data = models.JSONField()
    platforms = models.JSONField()
    filename = models.CharField(max_length=255, null=True, blank=True)
    
    def __str__(self):
        return f"CrossDockTask {self.id} - {self.status}"
```

## 2. ClickHouse Connection Service

Let's create a service for ClickHouse connections in the`common`app:

```python
# common/services/clickhouse.py
from clickhouse_driver import Client
from django.conf import settings
import contextlib

@contextlib.contextmanager
def get_clickhouse_client():
    """Context manager for ClickHouse client connections."""
    client = Client(
        settings.CLICKHOUSE_HOST,
        user=settings.CLICKHOUSE_USER,
        password=settings.CLICKHOUSE_PASSWORD
    )
    try:
        yield client
    finally:
        client.disconnect()
```

## 3. Excel Utilities

Create reusable Excel utilities in the`common`app:

```python
# common/utils/excel.py
from openpyxl import Workbook
import os
from django.conf import settings

def create_workbook():
    """Create a new Excel workbook."""
    return Workbook()

def save_workbook(wb, filename):
    """Save workbook to the exports directory."""
    # Create directory if it doesn't exist
    export_dir = os.path.join(settings.MEDIA_ROOT, 'exports')
    os.makedirs(export_dir, exist_ok=True)
    
    # Save the file
    file_path = os.path.join(export_dir, filename)
    wb.save(file_path)
    
    # Return the URL
    return os.path.join(settings.MEDIA_URL, 'exports', filename)
```

## 4. Cross-Dock Service

Now, let's create the core business logic for the cross-dock functionality:

```python
# cross_dock/services/percentage_cross.py
import pandas as pd
import io
import json
from datetime import datetime
from common.services.clickhouse import get_clickhouse_client
from common.utils.excel import create_workbook, save_workbook
import logging

logger = logging.getLogger(__name__)

def process_cross_dock_data(task_id, data, platforms):
    """
    Process cross-dock data and generate Excel file.
    
    Args:
        task_id: The task ID
        data: JSON data containing brand and article information
        platforms: List of platforms to query
        
    Returns:
        tuple: (progress percentage, file URL)
    """
    logger.info(f"Processing cross-dock data for task {task_id}")
    
    # Convert JSON data to DataFrame
    df = pd.read_json(io.StringIO(json.dumps(data)))
    
    # Create workbook
    wb = create_workbook()
    result_sheet = wb.active
    
    # Add headers
    headers = ["SKU", "Бренд", "Артикул", "Лучшая цена 1", "Количество 1", "Название поставщика 1",
               "Лучшая цена 2", "Количество 2", "Название поставщика 2",
               "Лучшая цена 3", "Количество 3", "Название поставщика 3"]
    
    for col_num, header in enumerate(headers, start=1):
        result_sheet.cell(row=1, column=col_num, value=header)
    
    # Get supplier data from ClickHouse
    with get_clickhouse_client() as client:
        # Get suppliers for the platform
        query = f"""
        SELECT DISTINCT dif_id
        FROM sup_stat.sup_list
        WHERE has(lists, '{platforms[0]}')
        """
        result = client.execute(query)
        sups_list = [str(item[0]) for item in result]
        sups = ", ".join(sups_list)
        
        # Process each row
        total_rows = len(df)
        for row_num, row_data in enumerate(df.iterrows(), start=2):
            index, row = row_data
            brand = str(row['Бренд'])
            article = str(row['Артикул'])
            logger.debug(f"Processing row {row_num}: {brand}, {article}")
            
            # Create SKU
            sku = f"{brand}|{article}"
            
            # Write basic data
            result_sheet.cell(row=row_num, column=1, value=sku)
            result_sheet.cell(row=row_num, column=2, value=brand)
            result_sheet.cell(row=row_num, column=3, value=article)
            
            # Query ClickHouse for price data
            # (Simplified for this example - actual query would be more complex)
            price_query = f"""
            SELECT price, quantity, supplier_name
            FROM sup_stat.some_price_table
            WHERE brand = '{brand}' AND article = '{article}'
            AND supplier_id IN ({sups})
            ORDER BY price ASC
            LIMIT 3
            """
            
            try:
                price_results = client.execute(price_query)
                
                # Write price data
                for i, (price, quantity, supplier_name) in enumerate(price_results, start=1):
                    col_offset = 3 + (i-1) * 3
                    result_sheet.cell(row=row_num, column=col_offset + 1, value=price)
                    result_sheet.cell(row=row_num, column=col_offset + 2, value=quantity)
                    result_sheet.cell(row=row_num, column=col_offset + 3, value=supplier_name)
            
            except Exception as e:
                logger.error(f"Error querying price data: {e}")
    
    # Save the workbook
    file_name = f"{task_id}.xlsx"
    file_url = save_workbook(wb, file_name)
    
    return "100%", file_url
```

## 5. Celery Task

Define the Celery task for processing cross-dock data:

```python
# cross_dock/tasks.py
from celery import shared_task
from .models import CrossDockTask
from .services.percentage_cross import process_cross_dock_data
import logging

logger = logging.getLogger(__name__)

@shared_task(bind=True)
def generate_cross_dock_excel(self, task_params):
    """
    Celery task to generate cross-dock Excel file.
    
    Args:
        task_params: Dictionary containing task parameters
        
    Returns:
        dict: Task result with progress and URL
    """
    task_id = self.request.id
    logger.info(f"Starting cross-dock task {task_id}")
    
    try:
        # Get or create task record
        task, created = CrossDockTask.objects.get_or_create(
            id=task_id,
            defaults={
                'status': 'RUNNING',
                'input_data': task_params['data'],
                'platforms': task_params['platforms'],
                'filename': task_params.get('filename', '')
            }
        )
        
        if not created:
            task.status = 'RUNNING'
            task.save()
        
        # Process data
        progress, file_url = process_cross_dock_data(
            task_id, 
            task_params['data'],
            task_params['platforms']
        )
        
        # Update task with result
        task.status = 'SUCCESS'
        task.result_url = file_url
        task.save()
        
        return {'progress': progress, 'url': file_url}
    
    except Exception as e:
        logger.exception(f"Error in cross-dock task: {e}")
        
        # Update task with error
        task = CrossDockTask.objects.get(id=task_id)
        task.status = 'FAILURE'
        task.error_message = str(e)
        task.save()
        
        raise
```

## 6. Django Views

Create the views for the cross-dock functionality:

```python
# cross_dock/views.py
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
from django.utils.decorators import method_decorator
from django.views import View
import json
from .tasks import generate_cross_dock_excel
from .models import CrossDockTask
from common.decorators import require_api_key
import logging

logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch')
@method_decorator(require_api_key, name='dispatch')
class CrossDockView(View):
    """View for starting cross-dock tasks and checking their status."""
    
    @method_decorator(require_POST)
    def post(self, request):
        """Start a new cross-dock task."""
        try:
            # Parse request data
            data = json.loads(request.body)
            
            # Prepare task parameters
            task_params = {
                'source_type': 'percentage_cross',
                'data': data['data'],
                'platforms': data['platforms'],
                'filename': data.get('filename', ''),
                'auto': data.get('auto', 'false')
            }
            
            # Start Celery task
            task = generate_cross_dock_excel.delay(task_params)
            
            return JsonResponse({"task_id": str(task.id)}, status=202)
        
        except Exception as e:
            logger.exception(f"Error starting cross-dock task: {e}")
            return JsonResponse({"error": str(e)}, status=500)
    
    def get(self, request):
        """Get status of cross-dock tasks."""
        try:
            # Get auto filter parameter
            auto_value = request.GET.get('auto', 'True')
            
            # Query tasks
            tasks = CrossDockTask.objects.all().order_by('-created_at')
            
            # Filter by auto if needed
            if auto_value.lower() == 'true':
                tasks = tasks.filter(input_data__auto='true')
            elif auto_value.lower() == 'false':
                tasks = tasks.filter(input_data__auto='false')
            
            # Format response
            response = {}
            for task in tasks:
                response[str(task.id)] = {
                    'status': task.status,
                    'progress': '100%' if task.status == 'SUCCESS' else '0%',
                    'url': task.result_url or '',
                    'created_at': task.created_at.isoformat(),
                    'filename': task.filename
                }
            
            return JsonResponse(response)
        
        except Exception as e:
            logger.exception(f"Error fetching cross-dock tasks: {e}")
            return JsonResponse({"error": str(e)}, status=500)
```

## 7. URL Configuration

Configure the URLs for the cross-dock app:

```python
# cross_dock/urls.py
from django.urls import path
from .views import CrossDockView

app_name = 'cross_dock'

urlpatterns = [
    path('start_percentage_cross/', CrossDockView.as_view(), name='start_percentage_cross'),
    path('tasks/cross_doc/', CrossDockView.as_view(), name='tasks_cross_doc'),
]
```

## 8. API Key Authentication

Create a decorator for API key authentication:

```python
# common/decorators.py
from django.http import JsonResponse
from django.conf import settings
import functools

def require_api_key(view_func):
    """
    Decorator to require API key for views.
    Checks for X-API-KEY and App-Key headers.
    """
    @functools.wraps(view_func)
    def wrapper(request, *args, **kwargs):
        api_key = request.headers.get('X-API-KEY')
        app_key = request.headers.get('App-Key')
        
        if api_key != settings.SECRET_KEY:
            return JsonResponse({"error": "Invalid API key"}, status=403)
        
        if app_key != settings.CLIENT_APP_KEY_ADMIN:
            return JsonResponse({"error": "Invalid app key"}, status=403)
        
        return view_func(request, *args, **kwargs)
    
    return wrapper
```

## 9. Settings Configuration

Add the necessary settings to your Django settings file:

```python
# config/django_config/base.py

# ClickHouse settings
CLICKHOUSE_HOST = '87.242.110.159'
CLICKHOUSE_USER = 'torgzap_vlastelin'
CLICKHOUSE_PASSWORD = '5483her!areA@'

# API authentication
CLIENT_APP_KEY_ADMIN = 'your-app-key-here'

# Media settings for Excel files
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Celery settings
CELERY_BROKER_URL = f'redis://{os.environ.get("REDIS_HOST", "localhost")}:{os.environ.get("REDIS_PORT", "6379")}/1'
CELERY_RESULT_BACKEND = f'redis://{os.environ.get("REDIS_HOST", "localhost")}:{os.environ.get("REDIS_PORT", "6379")}/1'
CELERY_TIMEZONE = 'Europe/Moscow'
CELERY_TASK_TRACK_STARTED = True
CELERY_TASK_TIME_LIMIT = 30 * 60
```

## 10. App Configuration

Configure the cross-dock app:

```python
# cross_dock/apps.py
from django.apps import AppConfig

class CrossDockConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'cross_dock'
    
    def ready(self):
        # Import signals or perform other initialization
        pass
```

## Summary

This technical plan provides a complete blueprint for implementing the cross-dock functionality in Django. The key improvements include:

1. **Simplified Data Flow**: Removed unnecessary async/await patterns
2. **Clear Separation of Concerns**:
   * Models for data storage
   * Services for business logic
   * Views for API endpoints
   * Utilities for common functions
3. **Improved Error Handling**: Consistent try/except blocks with proper logging
4. **Standardized Database Access**: Context managers for database connections
5. **Django Integration**: Leveraging Django's ORM, views, and authentication

When you're ready to implement, you can essentially copy these code examples into the appropriate files in your Django project structure, make any necessary adjustments, and you'll have a clean, maintainable implementation of the cross-dock functionality.
