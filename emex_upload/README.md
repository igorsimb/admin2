# Документация по загрузке данных Emex (v2)

Этот документ описывает полный процесс обработки и валидации файла с данными Emex, от загрузки в браузере до финальной вставки в базу данных.

## Общая картина

Процесс разделен на два основных асинхронных этапа, чтобы обеспечить максимальную интерактивность и обратную связь для пользователя, не блокируя интерфейс. Все тяжелые операции выполняются фоновыми обработчиками (Celery).

1.  **Этап Валидации:**
    -   Пользователь загружает файл. Сервер немедленно передает его первому фоновому обработчику (`validate_emex_file_task`).
    -   Пользователь перенаправляется на страницу статуса, где в реальном времени отображается пошаговый процесс проверки файла.
    -   По завершении валидации, обработчик создает временный, "чистый" файл (`.pkl`), содержащий только корректные строки, и сообщает фронтенду общее количество найденных ошибок.

2.  **Этап Вставки:**
    -   **Условная логика:** В зависимости от количества ошибок, фронтенд либо автоматически запускает процесс вставки (если ошибок мало), либо запрашивает подтверждение у пользователя.
    -   При подтверждении, запускается второй фоновый обработчик (`insert_emex_data_task`), которому передается путь к "чистому" файлу.
    -   Фронтенд отслеживает процесс вставки, показывая радиальный индикатор прогресса, который обновляется по мере загрузки данных в базу порциями (чанками).
    -   По окончании, отображается финальный статус (успех или ошибка) и ссылка для возврата на страницу загрузки.

---

## Детальный процесс и ключевые функции

### Этап 1: Загрузка и запуск валидации

-   **Файл:** `emex_upload/views.py`
-   **Функция:** `upload_file_view()`

Когда пользователь нажимает "Загрузить файл", эта функция Django:
1.  Сохраняет загруженный файл во временную папку на сервере.
2.  Создает новую фоновую задачу валидации, вызывая `validate_emex_file_task.delay()`.
3.  Немедленно отображает страницу статуса `upload_status.html`, передавая ей уникальный ID созданной задачи.

### Этап 2: Фоновая валидация и создание "чистого" файла

-   **Задача Celery:** `emex_upload/tasks.py` -> `validate_emex_file_task()`
-   **Сервис-оркестратор:** `emex_upload/services.py` -> `validate_file_and_animate_progress()`

Эта связка является ядром процесса проверки. `validate_emex_file_task` вызывает генератор `validate_file_and_animate_progress`, который выполняет конвейер проверок, отправляя отчеты о прогрессе на фронтенд после каждого шага.

#### Конвейер валидации

1.  **Чтение файла и проверка заголовков:** Определяется кодировка, и проверяется наличие всех обязательных колонок.
2.  **Проверка целостности строк (`RowIntegrityValidator`):**
    -   **Структура строк:** Находит строки, в которых не хватает колонок (проверяя на пустое значение в последней колонке).
    -   **Потеря данных при парсинге:** Идентифицирует строки, где нечисловые значения (например, текст) в числовых колонках были принудительно заменены на ноль.
3.  **Валидация бизнес-логики (`BusinessLogicValidator`):**
    -   Проверяет данные на соответствие бизнес-правилам (например, формат склада, корректность ИНН, логика общих сумм).
    -   Проверяет математическую корректность (`Количество * Цена = Сумма`).

#### Результат этапа

Все строки, провалившие любую из этих проверок, отбрасываются. Оставшиеся "чистые" данные собираются в единый DataFrame, который сохраняется в бинарный файл `.pkl` (для сохранения типов данных). Финальный результат, содержащий количество ошибок и путь к этому файлу, отправляется на фронтенд.

### Этап 3: Обратная связь и условное подтверждение (Фронтенд)

-   **Файл:** `emex_upload/templates/emex_upload/upload_status.html`

JavaScript на этой странице получает финальный результат валидации.
1.  Отображает итоговое сообщение: "Проверка завершена. Обнаружено X проблемных строк".
2.  Сравнивает количество ошибок с константой `ACCEPTABLE_ERROR_THRESHOLD`.
3.  Если ошибок больше, чем порог, показывает пользователю кнопки "Да, загрузить корректные строки" и "Отмена".
4.  Если ошибок меньше или равно порогу, автоматически переходит к следующему этапу.

### Этап 4: Запуск задачи вставки

-   **Файл:** `emex_upload/views.py`
-   **Функция:** `confirm_upload_view()`

Когда пользователь нажимает "Да, загрузить" (или это происходит автоматически), фронтенд отправляет POST-запрос на этот эндпоинт, передавая путь к `.pkl` файлу.
1.  Представление получает путь к файлу.
2.  Запускает вторую фоновую задачу `insert_emex_data_task.delay()`.
3.  Возвращает ID этой новой задачи на фронтенд.

### Этап 5: Фоновая вставка и мониторинг прогресса

-   **Задача Celery:** `emex_upload/tasks.py` -> `insert_emex_data_task()`
-   **Сервис:** `emex_upload/services.py` -> `insert_data_to_clickhouse()`
-   **Фронтенд:** `upload_status.html`

1.  **Задача:** `insert_emex_data_task` читает `.pkl` файл и передает DataFrame в сервис `insert_data_to_clickhouse`, вместе с экземпляром самой себя (`task=self`).
2.  **Сервис:** `insert_data_to_clickhouse` теперь вставляет данные не одним махом, а порциями по `INSERT_CHUNK_SIZE` строк. После каждой порции, он отправляет отчет о прогрессе (`task.update_state()`), указывая процент выполнения.
3.  **Фронтенд:** JavaScript, получив ID задачи вставки, открывает второе SSE-соединение для ее отслеживания. При получении отчетов о прогрессе, он обновляет радиальный индикатор. По завершении (успех или ошибка), он отображает финальное сообщение и ссылку "Назад к загрузке файла".